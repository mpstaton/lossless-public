const { knownErrorCases, helperFunctions, correctionFunctions } = require('../build-scripts/getKnownErrorsAndFixes.cjs');
const USER_OPTIONS = require('../build-scripts/getUserOptions.cjs');
const path = require('path');
const fs = require('fs');
const { promisify } = require('util');
const sleep = promisify(setTimeout);

// ================================================
// Configuration by the user
// ================================================
const TARGET_FILES = {
  targetDir: "site/src/content/tooling/Enterprise Jobs-to-be-Done"
};

const REPORTS_DIR = "site/scripts/data-or-content-generation/fixes-needed/errors-processing/";

// ================================================
// Sequence of cases to attempt to fix
// The sequence is identified by the order of the first key. 
// The report file name is generated by the REPORT_FILE_NAME_SYNTAX.
// The reportName variable here is the variable that is interpolated into the REPORT_FILE_NAME_SYNTAX.
// ================================================
const sequenceOfCasesToAttemptToFix = [
  { case: knownErrorCases.blockScalarSyntaxFoundInProperty, reportName: "Removed-Block-Scalar-Syntax-from-Properties" },
  { case: knownErrorCases.unquotedErrorMessageProperty, reportName: "Added-Quotes-to-Error-Message-Properties" },
  { case: knownErrorCases.improperCharacterSetSurroundingErrorMessage, reportName: "Fixed-Character-Set-Around-Error-Messages" },
  { case: knownErrorCases.undesiredQuotesPresentInURLProperty, reportName: "Removed-Quotes-from-URL-Properties" },
  { case: knownErrorCases.brokenUrlAcrossMultipleLines, reportName: "Fixed-URLs-Split-Across-Lines" },
  { case: knownErrorCases.unbalancedQuotesFoundInProperty, reportName: "Fixed-Unbalanced-Quotes" },
  { case: knownErrorCases.duplicateKeysInFrontmatter, reportName: "Removed-Duplicate-Keys" },
  { case: knownErrorCases.missingUrlPropertyNeededForOpenGraph, reportName: "Identified-Missing-URL-Property" },
  { case: knownErrorCases.uuidPropertyWithQuotes, reportName: "Removed-Quotes-from-UUID-Properties" },
  { case: knownErrorCases.assureOnlyOneSetOfSingleMarkQuotesAroundTimestampProperties, reportName: "Fixed-Timestamp-Property-Quotes" }
];

// ================================================
// Main Function
// ================================================
async function main() {
  console.log('Starting error case processing sequence...\n');

  for (const [index, errorCase] of sequenceOfCasesToAttemptToFix.entries()) {
    console.log(`Processing case ${index + 1}/10: ${errorCase.reportName}`);
    
    try {
      // Find all markdown files recursively
      const markdownFiles = [];
      const walkDir = (dir) => {
        const files = fs.readdirSync(dir);
        for (const file of files) {
          const fullPath = path.join(dir, file);
          if (fs.statSync(fullPath).isDirectory()) {
            walkDir(fullPath);
          } else if (file.endsWith('.md')) {
            markdownFiles.push(fullPath);
          }
        }
      };
      walkDir(TARGET_FILES.targetDir);

      // Track files for reporting
      let filesProcessed = 0;
      const namesOfFilesCorrected = [];
      const namesOfFilesWithIssue = [];

      // Process each file
      for (const markdownFilePath of markdownFiles) {
        try {
          const markdownContent = fs.readFileSync(markdownFilePath, 'utf8');
          const frontmatterData = helperFunctions.extractFrontmatter(markdownContent);
          
          if (!frontmatterData.success) continue;

          // Check if the issue exists
          const issueDetected = errorCase.case.detectError.test(frontmatterData.frontmatterString);
          
          if (issueDetected) {
            namesOfFilesWithIssue.push(markdownFilePath);
            
            const correctionFunction = correctionFunctions[errorCase.case.correctionFunction];
            if (!correctionFunction) {
              console.error(`Error: Correction function '${errorCase.case.correctionFunction}' not found for ${markdownFilePath}`);
              continue;
            }

            const result = await correctionFunction(markdownContent, markdownFilePath);
            
            if (result.modified) {
              namesOfFilesCorrected.push(markdownFilePath);
              fs.writeFileSync(markdownFilePath, result.content);
            }
          }
          
          filesProcessed++;
          
        } catch (error) {
          console.error(`Error processing ${markdownFilePath}:`, error);
        }
      }

      // Generate report name with index
      const today = new Date().toISOString().split('T')[0];
      let reportIndex = 1;
      let reportPath;
      
      do {
        const paddedIndex = String(reportIndex).padStart(2, '0');
        reportPath = path.join(REPORTS_DIR, `${today}-${errorCase.reportName}_${paddedIndex}.md`);
        reportIndex++;
      } while (fs.existsSync(reportPath));

      // Create report using your template
      const reportTemplate = `
## Summary of Files Processed
Files processed: ${filesProcessed}
Files with issue: ${namesOfFilesWithIssue.length}
Successful corrections: ${namesOfFilesCorrected.length}

### Files with Issues
${namesOfFilesWithIssue.map(file => `[[${path.basename(file, '.md')}]]`).join(', ')}

### Files Successfully Corrected
${namesOfFilesCorrected.map(file => `[[${path.basename(file, '.md')}]]`).join(', ')}
`;

      fs.writeFileSync(reportPath, reportTemplate);

      // Log summary to console
      console.log(`
Processing complete:
- Total files processed: ${filesProcessed}
- Files with issues: ${namesOfFilesWithIssue.length}
- Files corrected: ${namesOfFilesCorrected.length}
Report written to: ${reportPath}
`);

      // Wait between cases
      if (index < sequenceOfCasesToAttemptToFix.length - 1) {
        await sleep(2000);
      }

    } catch (error) {
      console.error(`Error processing ${errorCase.reportName}:`, error);
    }
  }

  // Create final summary report
  try {
    const today = new Date().toISOString().split('T')[0];
    let summaryIndex = 1;
    let summaryReportPath;
    
    do {
      const paddedIndex = String(summaryIndex).padStart(2, '0');
      summaryReportPath = path.join(REPORTS_DIR, `${today}-Complete-Error-Processing-Summary_${paddedIndex}.md`);
      summaryIndex++;
    } while (fs.existsSync(summaryReportPath));

    // Get all reports generated today
    const todaysReports = fs.readdirSync(REPORTS_DIR)
      .filter(file => file.startsWith(today))
      .map(file => {
        const content = fs.readFileSync(path.join(REPORTS_DIR, file), 'utf8');
        const lines = content.split('\n');
        const stats = {
          name: file,
          processed: 0,
          issues: 0,
          corrected: 0
        };

        lines.forEach(line => {
          if (line.includes('Files processed:')) stats.processed = parseInt(line.split(':')[1]);
          if (line.includes('Files with issue:')) stats.issues = parseInt(line.split(':')[1]);
          if (line.includes('Successful corrections:')) stats.corrected = parseInt(line.split(':')[1]);
        });

        return stats;
      });

    const summaryTemplate = `# Error Processing Summary for ${today}

## Overview
Total Reports Generated: ${todaysReports.length}

## Report Statistics
${todaysReports.map(report => `
### ${report.name}
- Files Processed: ${report.processed}
- Issues Found: ${report.issues}
- Corrections Made: ${report.corrected}
- Success Rate: ${report.issues > 0 ? Math.round((report.corrected / report.issues) * 100) : 0}%`).join('\n')}

## Aggregate Statistics
- Total Files Processed: ${todaysReports.reduce((sum, r) => sum + r.processed, 0)}
- Total Issues Found: ${todaysReports.reduce((sum, r) => sum + r.issues, 0)}
- Total Corrections Made: ${todaysReports.reduce((sum, r) => sum + r.corrected, 0)}
- Overall Success Rate: ${(() => {
    const totalIssues = todaysReports.reduce((sum, r) => sum + r.issues, 0);
    const totalCorrections = todaysReports.reduce((sum, r) => sum + r.corrected, 0);
    return totalIssues > 0 ? Math.round((totalCorrections / totalIssues) * 100) : 0;
  })()}%
`;

    fs.writeFileSync(summaryReportPath, summaryTemplate);
    console.log(`Summary report written to: ${summaryReportPath}`);
  } catch (error) {
    console.error('Error creating summary report:', error);
  }

  console.log('All error cases processed.');
}

// Run the main function
main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
